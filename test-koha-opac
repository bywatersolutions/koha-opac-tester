#!/usr/bin/perl

use Modern::Perl;

use Getopt::Long;
use URI::Escape qw( uri_escape );
use WWW::Curl::Easy;

my $verbose;
my $domain;
my $search_term = "test";
my $look_for;

GetOptions(
    "v|verbose"       => \$verbose,
    "d|domain:s"      => \$domain,
    "s|search-term:s" => \$search_term,
    "l|look-for:s"    => \$look_for,
);

$look_for ||= $search_term;

unless ($domain) {
    say "-d ( --domain ) option is required";
    exit 0;
}

unless ($search_term) {
    say "-s ( --search-term ) option is required";
    exit 0;
}

$search_term = uri_escape($search_term);

my $url = "https://$domain/cgi-bin/koha/opac-search.pl?q=$search_term";

say "URL: $url" if $verbose;

my $curl = WWW::Curl::Easy->new;

$curl->setopt( CURLOPT_HEADER, 1 );
$curl->setopt( CURLOPT_URL,    $url );

# A filehandle, reference to a scalar or reference to a typeglob can be used here.
my $response_body;
$curl->setopt( CURLOPT_WRITEDATA, \$response_body );

# Starts the actual request
my $retcode = $curl->perform;

# Looking at the results...
if ( $retcode == 0 ) {
    say "Transfer went ok" if $verbose;
    my $response_code = $curl->getinfo(CURLINFO_HTTP_CODE);

    if ( $response_code ne '200' ) {
        say "Bad Response Code!: $response_code" if $verbose;
        exit 1;
    }

    if ( index( $response_body, 'No results found!' ) != -1 ) {
        say "Page returned 'No results found!'";
        exit 1;
    }

    if ( index( $response_body, $look_for ) != -1 ) {
        say "Found the string '$look_for' in the returned HTML.";
        exit 0;
    } else {
        say "Did *not* find the string '$look_for' in the returned HTML.";
        exit 1;
    }
}
else {
    # Error code, type of error, error message
    print(  "An error happened: $retcode "
          . $curl->strerror($retcode) . " "
          . $curl->errbuf
          . "\n" );
    exit 1;
}
